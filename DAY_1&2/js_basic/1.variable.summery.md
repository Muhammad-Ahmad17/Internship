1:DECLEARATION 
var => 
	old
	function scoped

let const =>
	new 
	block scoped

let: can be reassigned
const: can't be reassigned
	   there are also const objects which only prevents reassigning the reference of the object, not the internal properties.also for arrays

2:TYPE
PRIMITIVE
all datatypes are auto detect itself we just use let 
> NUMBERS ==> all type of number int float ... they are also equal (both == & ===) like (2===2 or 2==2.0 and 2=='2' but {2==='2'(not)})
		  ==>	let sum = 0.1 + 0.2;
				console.log(sum);                // 0.30000000000000004
				console.log(Number(sum.toFixed(2))); // 0.3
		  ==>isNan: console.log(isNaN("abc")); // true
				    console.log(isNaN("2.2")); // false (string is coerced to number)           
			>toFixed: console.log(sum.toFixed(0)); // 3.14 --> 3
					  console.log(sum.toFixed(1)); // 3.14 --> 3.1
> NULL: explicitly initialize
		console.log(undefined == null);  // true (loose equality)
		console.log(undefined === null); // false (strict equality)
		>	// typeof null returns "object" due to a legacy bug
			// null is not an object, but this behavior remains for compatibility

console.log(undefined == null); // true (loose equality)
console.log(typeof undefined == null); // false (comparing types)
console.log(typeof null == null); // false (comparing types)
 - Use undefined for variables that have not been assigned a value
 - Use null when you want to explicitly indicate "no value" or "empty"
	/* SUMMARY: NULL vs UNDEFINED */
// undefined: variable declared but not assigned, missing object property, function with no return
// null: intentional absence of value, explicit "empty" assignment


> UNDEFINED: 
		let a 
		console.log(a) // undefined
		> accessing a object attribute which not exist
		
> STRING:
		===> immutable unlike arrays
> SYMBOLS:
		===>  	const ID1 = Symbol(1);
				const ID2 = Symbol(1);
				console.log(ID1 == ID2); // false ( also valid for === )		
> BIGINT:
> BOOL:

NON PRIMITIVE
> OBJECTS:


{} -> NAN (empty object cannot be converted to a number)
[] -> 0(empty array converted to number)
true -> 1
null -> 0



3:/*TYPE COERCION AND CONVERSION*/

/*Automatic Type Coercion Examples*/

console.log("5" + 3);         // "53" (number converted to string)
console.log("5" - 3);         // 2 (string converted to number)
console.log("5" * 2);         // 10 (string converted to number)
console.log("10" / 2);        // 5 (string converted to number)
console.log("5" + null);      // "5null" (null converted to string)
console.log("5" - null);      // 5 (null converted to 0)
console.log("5" + undefined); // "5undefined" (undefined converted to string)
console.log("5" - undefined); // NaN (undefined cannot be converted to number)
console.log(10 / "2");        // 5 (string "2" converted to number)

/* Boolean Coercion */
console.log(5 + true);        // 6 (true converted to 1)
console.log(5 + false);       // 5 (false converted to 0)
console.log("5" == 5);        // true (string converted to number)
console.log("true" == true);  // false (no meaningful conversion)

/* Equality vs. Strict Equality */
console.log(5 == "5");            // true (string converted to number)
console.log(5 === "5");           // false (no coercion)
console.log(null == undefined);   // true (special coercion rule)
console.log(null === undefined);  // false (strict equality, no coercion)

/* Logical Operations */
console.log(null || "default");   // "default" (null is falsy)
console.log(0 && "value");        // 0 (0 is falsy, short-circuits)
console.log(1 && "value");        // "value" (1 is truthy)

/* Objects and Type Coercion */
console.log({} + []);             // "[object Object]" (toString of {})
console.log([] + []);             // "" (empty strings concatenated)
console.log([] == 0);             // true (empty array converted to number)

/* Unary Operators */
console.log(+"5");                // 5 (string converted to number)
console.log(+true);               // 1 (true converted to number)
console.log(+null);               // 0 (null converted to number)
console.log(+undefined);          // NaN (undefined cannot be converted to a number)
console.log(+{});                 // NaN (empty object cannot be converted to a number)
console.log(+[]);                 // 0 (empty array converted to number)



4:/*Manual Type Conversion*/

let num = Number("42");           // Convert string to number

let str = String(42);             // Convert number to string

let bool = Boolean(1);            // Convert to boolean
// The `Boolean` constructor converts any truthy value to `true`, and any falsy value (like `0`, `""`, `null`, `undefined`, or `NaN`) to `false`.
// Here, `1` is truthy, so `bool` will be `true`.


5:HOISTING

/* Hoisting with var **/ undefined
console.log(a);  // undefined (var is hoisted, but initialization happens later)
var a = 5;
console.log(a);  // 5 (a is now initialized)

/* Hoisting with let and const **/ error
console.log(b);  // ReferenceError: Cannot access 'b' before initialization (let/const are hoisted but not initialized)
let b = 10;

console.log(c);  // ReferenceError: Cannot access 'c' before initialization (const also hoisted but not initialized)
const c = 20;

/* Hoisting with Function Declarations **/  ok 
console.log(foo());  // "Hello, World!" (function declaration is hoisted with its definition)
function foo() {
    return "Hello, World!";
}
Function declarations are hoisted and fixed at compile-time, so they behave like static definitions.
Function expressions are dynamic, assigned at runtime.
/* Hoisting with Function Expressions **/ error
console.log(bar());  // TypeError: bar is not a function (only the variable declaration is hoisted, not the function body)
var bar = function() {
    return "Hello, World!";
};

/* Hoisting in Loops **/
for (let i = 0; i < 3; i++) {
    console.log(i);  // Outputs 0, 1, 2 (let creates a new variable for each iteration)
}
/*imp: whats the value of j */
for (var j = 0; j < 3; j++) {
    console.log(j);  // Outputs 0, 1, 2 (var is hoisted and accessible outside the loop)
}
console.log(j);  // Outputs 3 (var is function-scoped, so it is accessible outside the loop)
console.log(i);  // ReferenceError: i is not defined (let is block-scoped, so it is not accessible outside the loop)

/* Key Takeaways

1. var: Hoisted and initialized to undefined.
2. let and const: Hoisted but not initialized (temporal dead zone).
3. Function declarations are fully hoisted.
4. Function expressions only hoist the variable, not the function body.
5. let and const have block scope, var has function/global scope.



/*COMMON PITFALLS AND GOTCHAS*/

/*
{} -> NAN (empty object cannot be converted to a number)
[] -> 0(empty array converted to number)
true -> 1
null -> 0
*/

/*Type Coercion Issues*/

console.log([] + {});          // "[object Object]" - Array converted to string
// An array (`[]`) and an object (`{}`) are coerced to their string representations, resulting in `[object Object]`.

console.log([] + []);          // "" (empty string)
// Two empty arrays are coerced into empty strings and concatenated together, producing an empty string.

console.log({} + []);          // 0 (quirk in some browsers)
// This case can return `0` in some environments, depending on how JavaScript handles the empty object and array.


/*Number Precision*/

let decimal = 0.1 + 0.2;       // 0.30000000000000004 (floating-point precision issue)
console.log(decimal === 0.3);  // false
// JavaScript cannot accurately represent some decimal numbers in binary floating point, leading to precision errors like this one.


/*Const Mutation*/

const arr = [1, 2, 3];
arr.push(4);                   // Valid! Arrays are mutable
// Even though `arr` is declared with `const`, it is still mutable. You can modify the contents of the array, but you cannot reassign `arr` to a new array.

